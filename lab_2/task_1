n = 10 * 5 + 3.14
При выполнении  этой строки компилятор будет искать значение в ближайшей области видимости 
Иными словами, при поиске значения а комплятор сначала проверит область видимости функции, и
если там указанное имя не будет обнаружено он обратится в надстоящее пространство имен, 
конкретно здесь глобальное
L = 10 по той же причине
И при выполнении арифметической операции происходит приведение типов по следующим правилам:

1 . Если один из операндов имеет тип l ong douЬle, то другой операнд преобразуется в long douЬle.
2. Иначе, если один из операндов имеет тип douЬle, то другой операнд преобразуется в douЫe.
3. Иначе, если один из операндов имеет тип float, то другой операнд преобразуется в float.
4. Иначе, операнды имеют целочисленный тип, поэтому выполняется целочисленное расширение.
5. В этом случае, если оба операнда имеют знак или оба операнда беззнаковые,
и один из них имеет меньший ранг, чем другой, он преобразуется в больший
ранг.
6. Иначе, один операнд имеет знак, а другой беззнаковый. Если беззнаковый операнд имеет больший ранг, чем операнд со знаком, последний преобразует в тип
беззнакового операнда.
7. Иначе, если тип со знаком может представить все значения беззнакового типа,
беззнаковый операнд преобразуется к типу операнда со знаком.
8. Иначе, оба операнда преобразуются в беззнаковую версию типа со знаком.

Описанная ситуация попадает под пункт 2 следовательно <b>n = 53.14</b>

m = 100 / 123 + 456 = 456
функция g описана не в теле main и тогда поиск имени а будет проходить в глобальном области видимости а д и т переданные
в качестве аргементов соотвественно в область видимости аргументов функции

